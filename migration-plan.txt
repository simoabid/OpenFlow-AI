================================================================================
        OPENFLOW-AI: KOTLIN ANDROID TO REACT NATIVE EXPO MIGRATION PLAN
================================================================================
Created: February 13, 2026
Estimated Duration: 6-12 months (team of 3-5 developers)
Complexity: VERY HIGH
Risk Level: HIGH
================================================================================

TABLE OF CONTENTS
1. Executive Summary
2. Feasibility Analysis & Critical Blockers
3. Architecture Transformation Strategy
4. Phase-by-Phase Migration Plan
5. Technology Stack Mapping
6. Component Migration Map
7. Native Module Requirements
8. API & Service Integration
9. Testing Strategy
10. Risk Mitigation
11. Alternative Approaches
12. Detailed Implementation Steps
13. Resource Requirements
14. Success Criteria

================================================================================
1. EXECUTIVE SUMMARY
================================================================================

MIGRATION GOAL:
Transform OpenFlow-AI from a native Kotlin Android app to a cross-platform
React Native Expo application while maintaining core functionality.

FEASIBILITY: POSSIBLE BUT EXTREMELY CHALLENGING ‚ö†Ô∏è

Key Points:
‚úÖ POSSIBLE: UI layer, business logic, API integrations, voice features
‚ö†Ô∏è CHALLENGING: Background services, accessibility features, screen automation
‚ùå IMPOSSIBLE (without native modules): Android Accessibility Service equivalent

RECOMMENDED APPROACH: Hybrid Migration
- React Native Expo for UI, business logic, and most features
- Custom Native Modules for accessibility and screen automation (Android/iOS)
- Gradual migration (not big-bang rewrite)

CRITICAL DECISION POINT:
The app's core feature (autonomous UI automation via Accessibility Service) has
NO direct React Native equivalent. This requires custom native modules, which
defeats some benefits of React Native and is NOT supported in managed Expo.

================================================================================
2. FEASIBILITY ANALYSIS & CRITICAL BLOCKERS
================================================================================

2.1 COMPLETE BLOCKERS (Managed Expo)
-------------------------------------
‚ùå Android Accessibility Service:
   - Core feature for screen reading and UI automation
   - NO React Native equivalent exists
   - Requires native Android code
   - NOT available in managed Expo
   - Solution: Must use Expo bare workflow or custom dev client

‚ùå Foreground Services with Custom Actions:
   - Required for always-on agent execution
   - Limited support in React Native
   - Expo has restrictions
   - Solution: Native modules required

‚ùå System-Level Gesture Control:
   - Automated taps, swipes outside app
   - Not possible in React Native sandbox
   - Solution: Native modules required

‚ùå Advanced Permissions:
   - QUERY_ALL_PACKAGES: Not accessible from React Native
   - BIND_ACCESSIBILITY_SERVICE: Requires native setup
   - Solution: Native permission handling

2.2 SIGNIFICANT CHALLENGES (Solvable)
--------------------------------------
‚ö†Ô∏è Background Task Execution:
   - React Native has limitations
   - Solutions: react-native-background-actions, TaskManager (Expo)
   - Trade-offs: Less reliable than native

‚ö†Ô∏è Screen Capture:
   - Limited React Native APIs
   - Solutions: react-native-view-shot (in-app only), native modules for system
   - Trade-offs: May need native code

‚ö†Ô∏è Complex State Management:
   - Agent loop with persistent state
   - Solutions: Redux, MobX, Zustand with AsyncStorage
   - Trade-offs: More complex than Kotlin coroutines

‚ö†Ô∏è Performance:
   - JavaScript slower than Kotlin for intensive operations
   - Solutions: Native modules for critical paths, Hermes engine
   - Trade-offs: May need optimization work

2.3 EASILY MIGRATABLE
----------------------
‚úÖ Voice Features (TTS/STT):
   - expo-speech, expo-speech-recognition
   - react-native-voice (for advanced STT)

‚úÖ Wake Word Detection:
   - @picovoice/react-native-porcupine available

‚úÖ Firebase Integration:
   - @react-native-firebase/* packages
   - Full feature parity

‚úÖ UI Components:
   - React Native components
   - react-native-paper (Material Design)

‚úÖ API Integrations:
   - Axios or Fetch for HTTP calls
   - Same APIs work

‚úÖ Navigation:
   - React Navigation
   - Similar to Android activities

‚úÖ Local Storage:
   - AsyncStorage, SQLite, Realm
   - Good alternatives to Room

2.4 FINAL VERDICT
-----------------
MIGRATION IS POSSIBLE IF:
1. You accept using Expo Bare Workflow or custom dev client (not managed Expo)
2. You invest in building custom native modules for accessibility features
3. You're prepared for significant development effort (6-12 months)
4. You accept some feature compromises or platform-specific code

RECOMMENDED: Stay with Native Android OR use Flutter (better native access)

IF PROCEEDING: Follow hybrid approach with extensive native modules

================================================================================
3. ARCHITECTURE TRANSFORMATION STRATEGY
================================================================================

3.1 CURRENT ARCHITECTURE (Kotlin/Android)
------------------------------------------
```
Android App (Kotlin)
‚îú‚îÄ‚îÄ Accessibility Service (Native Android)
‚îÇ   ‚îú‚îÄ‚îÄ Screen Reading
‚îÇ   ‚îú‚îÄ‚îÄ UI Element Detection
‚îÇ   ‚îî‚îÄ‚îÄ Gesture Execution
‚îú‚îÄ‚îÄ Agent Service (Foreground Service)
‚îÇ   ‚îú‚îÄ‚îÄ Agent Loop (SENSE ‚Üí THINK ‚Üí ACT)
‚îÇ   ‚îú‚îÄ‚îÄ LLM Integration (Gemini)
‚îÇ   ‚îî‚îÄ‚îÄ Action Executor
‚îú‚îÄ‚îÄ UI Layer (Compose + Activities)
‚îú‚îÄ‚îÄ Voice (TTS/STT - Android APIs)
‚îú‚îÄ‚îÄ Wake Word (Picovoice)
‚îú‚îÄ‚îÄ Background Services
‚îÇ   ‚îú‚îÄ‚îÄ Wake Word Service
‚îÇ   ‚îú‚îÄ‚îÄ Trigger Monitoring
‚îÇ   ‚îî‚îÄ‚îÄ Notification Listener
‚îî‚îÄ‚îÄ Data Layer (Room + SharedPreferences)
```

3.2 TARGET ARCHITECTURE (React Native Expo)
--------------------------------------------
```
Expo App (TypeScript + React Native)
‚îú‚îÄ‚îÄ Native Modules (Custom - Bridge to Android/iOS)
‚îÇ   ‚îú‚îÄ‚îÄ AccessibilityModule (Android)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Screen Capture
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ UI Tree Extraction
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Gesture Dispatch
‚îÇ   ‚îú‚îÄ‚îÄ ScreenAutomationModule (iOS - limited)
‚îÇ   ‚îî‚îÄ‚îÄ BackgroundServiceModule
‚îÇ       ‚îú‚îÄ‚îÄ Agent Execution
‚îÇ       ‚îî‚îÄ‚îÄ Trigger Monitoring
‚îú‚îÄ‚îÄ React Native App Layer
‚îÇ   ‚îú‚îÄ‚îÄ Agent Core (TypeScript)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Agent Loop
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ State Management (Redux/Zustand)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LLM Client (Gemini)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Action Coordinator
‚îÇ   ‚îú‚îÄ‚îÄ UI Layer (React Native + Expo)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Screens (React Navigation)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Components (React Native Paper)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Styling (StyleSheet/Tailwind)
‚îÇ   ‚îú‚îÄ‚îÄ Voice Layer (Expo + RN Libraries)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TTS (expo-speech)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ STT (expo-speech-recognition)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Wake Word (@picovoice/react-native-porcupine)
‚îÇ   ‚îú‚îÄ‚îÄ Services Layer
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Background Tasks (expo-task-manager)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Notifications (expo-notifications)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Triggers (local scheduling)
‚îÇ   ‚îî‚îÄ‚îÄ Data Layer
‚îÇ       ‚îú‚îÄ‚îÄ AsyncStorage (simple data)
‚îÇ       ‚îú‚îÄ‚îÄ SQLite (structured data)
‚îÇ       ‚îî‚îÄ‚îÄ FileSystem (expo-file-system)
‚îî‚îÄ‚îÄ Firebase Integration (@react-native-firebase)
    ‚îú‚îÄ‚îÄ Auth
    ‚îú‚îÄ‚îÄ Firestore
    ‚îú‚îÄ‚îÄ Analytics
    ‚îî‚îÄ‚îÄ Crashlytics
```

3.3 KEY ARCHITECTURAL CHANGES
------------------------------
1. **Language Shift**:
   - Kotlin ‚Üí TypeScript (strongly typed JavaScript)
   - Coroutines ‚Üí async/await Promises
   - Sealed Classes ‚Üí TypeScript Union Types

2. **UI Paradigm**:
   - Jetpack Compose ‚Üí React Native JSX
   - Activities/Fragments ‚Üí React Navigation Screens
   - ViewBinding ‚Üí React State & Props

3. **State Management**:
   - Room + ViewModel ‚Üí Redux/Zustand + AsyncStorage
   - LiveData ‚Üí React State/Context
   - SharedPreferences ‚Üí AsyncStorage

4. **Concurrency**:
   - Kotlin Coroutines ‚Üí async/await + Promise.all
   - Channel ‚Üí EventEmitter or RxJS
   - Flow ‚Üí RxJS or custom observables

5. **Native Bridge**:
   - Direct Android APIs ‚Üí Native Modules ‚Üí JavaScript Bridge
   - Performance overhead from serialization

3.4 ARCHITECTURE DECISION RECORDS
----------------------------------
ADR-001: Use Expo Bare Workflow
- Reason: Need custom native modules for accessibility
- Trade-off: Lose managed Expo convenience

ADR-002: TypeScript over JavaScript
- Reason: Type safety critical for large codebase
- Trade-off: Additional build complexity

ADR-003: Redux Toolkit for State
- Reason: Complex agent state needs robust solution
- Trade-off: Learning curve, boilerplate

ADR-004: Native Modules for Core Features
- Reason: Accessibility and automation require native code
- Trade-off: Platform-specific maintenance

ADR-005: React Navigation v6
- Reason: Industry standard, well-maintained
- Trade-off: Different patterns from Android Navigation

================================================================================
4. PHASE-BY-PHASE MIGRATION PLAN
================================================================================

STRATEGY: Strangler Fig Pattern (Gradual Replacement)
Not recommended for big-bang rewrite. Consider parallel development.

PHASE 0: PREPARATION (4-6 weeks)
---------------------------------
Week 1-2: Analysis & Planning
‚ñ° Audit entire codebase (done via summary.txt)
‚ñ° Identify all dependencies
‚ñ° Map all Android-specific features
‚ñ° Create detailed component inventory
‚ñ° Assess team React Native expertise
‚ñ° Set up development environments

Week 3-4: Proof of Concept
‚ñ° Build React Native prototype
‚ñ° Test critical native module (accessibility proof)
‚ñ° Validate Firebase integration
‚ñ° Test voice features (TTS/STT/wake word)
‚ñ° Performance baseline testing
‚ñ° Decision: Go/No-Go

Week 5-6: Project Setup
‚ñ° Initialize Expo bare workflow project
‚ñ° Set up TypeScript configuration
‚ñ° Configure ESLint, Prettier
‚ñ° Set up CI/CD pipelines
‚ñ° Create native module scaffolding (Android/iOS)
‚ñ° Set up development/staging/production environments

PHASE 1: FOUNDATION (8-10 weeks)
---------------------------------
Sprint 1-2: Core Infrastructure
‚ñ° Project structure setup
‚ñ° Navigation framework (React Navigation)
‚ñ° State management setup (Redux Toolkit)
‚ñ° API client layer (Axios + interceptors)
‚ñ° Error handling framework
‚ñ° Logging infrastructure
‚ñ° Environment configuration
‚ñ° Build tooling

Sprint 3-4: Native Modules - Foundation
‚ñ° Android Accessibility Service bridge
  - Screen capture module
  - UI tree extraction module
  - Gesture execution module
‚ñ° iOS equivalent (limited functionality)
‚ñ° Module testing framework
‚ñ° Documentation

Sprint 5: Data Layer
‚ñ° AsyncStorage wrapper
‚ñ° SQLite setup (expo-sqlite)
‚ñ° File system manager (expo-file-system)
‚ñ° Data migration utilities
‚ñ° Offline-first architecture

PHASE 2: CORE FEATURES (12-16 weeks)
-------------------------------------
Sprint 6-7: Agent Core Logic
‚ñ° Port Agent.kt to TypeScript
  - Agent state machine
  - SENSE ‚Üí THINK ‚Üí ACT loop
  - Step management
  - History tracking
‚ñ° Port PromptBuilder
  - System prompt integration
  - Dynamic prompt construction
‚ñ° Port MemoryManager
  - Short-term memory
  - Message management

Sprint 8-9: LLM Integration
‚ñ° Port GeminiAPI to TypeScript
  - API client with retry logic
  - Key rotation system
  - Proxy and direct mode
  - Response parsing
‚ñ° Port action system
  - Action definitions (TypeScript types)
  - Action serializer/deserializer
  - Action executor framework

Sprint 10-11: Perception & Actions
‚ñ° Port Perception system
  - Screen state analyzer
  - Element parser
  - Screenshot handling
‚ñ° Port Action Executor
  - Bridge to native gesture modules
  - File operations
  - App launching
  - Web search integration

Sprint 12-13: Voice Features
‚ñ° TTS implementation (expo-speech + Google Cloud TTS)
  - Multi-voice support
  - Audio caching
  - Queue management
‚ñ° STT implementation (expo-speech-recognition)
  - Press-and-hold interface
  - Continuous listening
‚ñ° Speech coordinator
  - STT/TTS coordination
  - Thread safety

Sprint 14-15: Wake Word System
‚ñ° Picovoice integration (@picovoice/react-native-porcupine)
  - Wake word detection
  - Background listening
  - Battery optimization
‚ñ° Wake word service
  - Foreground service (native module)
  - Notification management

Sprint 16: Background Services
‚ñ° Background task framework
  - expo-task-manager integration
  - Native background service module
‚ñ° Agent service port
  - Long-running agent execution
  - Task queue management

PHASE 3: USER INTERFACE (10-12 weeks)
--------------------------------------
Sprint 17-18: Core Screens
‚ñ° Login/Auth screen
  - Firebase Auth integration
  - Google OAuth
  - Email/password
‚ñ° Main screen
  - Voice input interface
  - Task status display
  - Navigation
‚ñ° Settings screen
  - Preferences
  - Account management

Sprint 19-20: Feature Screens
‚ñ° Chat/Dialogue screens
  - Conversation UI
  - Message bubbles
  - Input methods
‚ñ° Clarification dialogue
  - Question flow
  - Progress indicator
  - Voice/text input

Sprint 21-22: Management Screens
‚ñ° Triggers screen
  - Trigger list
  - Create/edit/delete
  - Type-specific UI
‚ñ° Moments/History screen
  - Task history
  - Details view
‚ñ° Memories screen (if re-enabling)

Sprint 23-24: Additional Screens & Polish
‚ñ° Onboarding flow
  - Permission screens
  - Setup wizard
‚ñ° Pro/Subscription screen
  - Purchase flow
  - Subscription management
‚ñ° UI Polish
  - Animations
  - Dark mode
  - Accessibility (ironic!)

PHASE 4: INTEGRATION & FEATURES (8-10 weeks)
---------------------------------------------
Sprint 25-26: Trigger System
‚ñ° Trigger manager
  - CRUD operations
  - Persistence
‚ñ° Scheduled triggers
  - Alarm scheduling (expo-notifications)
  - Recurrence logic
‚ñ° Notification triggers
  - Notification listener (native module)
  - Matching logic
‚ñ° Charging triggers

Sprint 27-28: Firebase Integration
‚ñ° Authentication
  - OAuth flows
  - Session management
‚ñ° Firestore
  - Data sync
  - Offline support
‚ñ° Analytics & Crashlytics
  - Event tracking
  - Error reporting
‚ñ° Remote Config
  - Feature flags

Sprint 29-30: Additional Features
‚ñ° Overlay system (native modules)
  - Toast notifications
  - Floating UI elements
‚ñ° Visual feedback
  - Audio wave visualization
  - Status indicators
‚ñ° File system operations
  - todo.md management
  - results.md management

PHASE 5: TESTING & OPTIMIZATION (8-12 weeks)
---------------------------------------------
Sprint 31-33: Testing
‚ñ° Unit tests (Jest)
  - Business logic
  - Utilities
  - State management
‚ñ° Integration tests
  - API integrations
  - Native modules
‚ñ° E2E tests (Detox)
  - Critical user flows
  - Voice interaction
‚ñ° Manual testing
  - All features
  - Platform-specific testing

Sprint 34-36: Optimization
‚ñ° Performance optimization
  - React Native profiling
  - Native module optimization
  - Memory management
‚ñ° Bundle size optimization
  - Code splitting
  - Tree shaking
  - Asset optimization
‚ñ° Battery optimization
  - Background task tuning
  - Wake lock management

Sprint 37-38: Polish & Bug Fixes
‚ñ° Bug triage and fixing
‚ñ° UX improvements
‚ñ° Accessibility improvements
‚ñ° Documentation updates

PHASE 6: DEPLOYMENT (4-6 weeks)
--------------------------------
Sprint 39-40: Pre-Launch
‚ñ° Production build setup
  - Code signing (Android/iOS)
  - Release channels
‚ñ° App store preparation
  - Screenshots
  - Descriptions
  - Privacy policy
‚ñ° Beta testing
  - TestFlight (iOS)
  - Internal testing (Android)

Sprint 41-42: Launch
‚ñ° Staged rollout
  - 10% ‚Üí 50% ‚Üí 100%
‚ñ° Monitoring
  - Crashlytics
  - Performance monitoring
  - User feedback
‚ñ° Post-launch support
  - Bug fixes
  - User support

TOTAL TIMELINE: 54-72 weeks (13-18 months)
This is conservative. Could be faster with larger team or reduced scope.

================================================================================
5. TECHNOLOGY STACK MAPPING
================================================================================

5.1 DEVELOPMENT FRAMEWORK
--------------------------
Kotlin/Android ‚Üí React Native with Expo

Current:
‚Ä¢ Android SDK 24-35
‚Ä¢ Kotlin 2.0.21
‚Ä¢ Jetpack Compose
‚Ä¢ Android Gradle Plugin 8.9.2

Target:
‚Ä¢ React Native 0.73+
‚Ä¢ Expo SDK 50+
‚Ä¢ TypeScript 5.3+
‚Ä¢ Metro bundler

5.2 LANGUAGE
------------
Kotlin ‚Üí TypeScript

Migration Notes:
‚Ä¢ Sealed classes ‚Üí Discriminated unions
‚Ä¢ Data classes ‚Üí TypeScript interfaces/types
‚Ä¢ Extension functions ‚Üí Utility functions
‚Ä¢ Coroutines ‚Üí async/await
‚Ä¢ Flow ‚Üí RxJS or custom observables

5.3 UI FRAMEWORK
----------------
Jetpack Compose ‚Üí React Native

Components:
‚Ä¢ Compose UI ‚Üí React Native core components
‚Ä¢ Material3 ‚Üí react-native-paper
‚Ä¢ Navigation Component ‚Üí React Navigation
‚Ä¢ ViewModel ‚Üí React hooks (useState, useReducer)

5.4 STATE MANAGEMENT
--------------------
Room + ViewModel + LiveData ‚Üí Redux Toolkit + AsyncStorage

Current:
‚Ä¢ Room Database
‚Ä¢ ViewModel
‚Ä¢ LiveData
‚Ä¢ StateFlow

Target:
‚Ä¢ Redux Toolkit (complex state)
‚Ä¢ Zustand (simpler alternative)
‚Ä¢ React Context (global state)
‚Ä¢ AsyncStorage (persistence)
‚Ä¢ expo-sqlite (structured data)

5.5 NETWORKING
--------------
OkHttp ‚Üí Axios or Fetch

Current:
‚Ä¢ OkHttp 5.0.0-alpha.16
‚Ä¢ Moshi for JSON

Target:
‚Ä¢ Axios (recommended)
‚Ä¢ Native Fetch API (alternative)
‚Ä¢ Built-in JSON parsing

5.6 FIREBASE
------------
Firebase Android SDK ‚Üí React Native Firebase

Current:
‚Ä¢ Firebase BOM 34.3.0
‚Ä¢ Native Android SDK

Target:
‚Ä¢ @react-native-firebase/app
‚Ä¢ @react-native-firebase/auth
‚Ä¢ @react-native-firebase/firestore
‚Ä¢ @react-native-firebase/analytics
‚Ä¢ @react-native-firebase/crashlytics
‚Ä¢ @react-native-firebase/remote-config

5.7 VOICE FEATURES
------------------
Android TTS/STT ‚Üí Expo + React Native Voice

TTS:
‚Ä¢ expo-speech (basic)
‚Ä¢ Custom Google Cloud TTS (keep existing)
‚Ä¢ Audio playback: expo-av

STT:
‚Ä¢ expo-speech-recognition (new Expo module)
‚Ä¢ react-native-voice (alternative)
‚Ä¢ @react-native-community/voice (another option)

Wake Word:
‚Ä¢ @picovoice/react-native-porcupine ‚úì (Available!)

5.8 PERMISSIONS
---------------
Android Permissions ‚Üí expo-permissions + native modules

Basic:
‚Ä¢ expo-permissions
‚Ä¢ expo-location
‚Ä¢ expo-contacts
‚Ä¢ expo-notifications

Advanced (native modules):
‚Ä¢ Accessibility Service
‚Ä¢ Notification Listener
‚Ä¢ Draw Over Apps

5.9 BACKGROUND TASKS
--------------------
Android Services ‚Üí expo-task-manager + native modules

Current:
‚Ä¢ Foreground Services
‚Ä¢ Background Services
‚Ä¢ WorkManager

Target:
‚Ä¢ expo-task-manager
‚Ä¢ expo-background-fetch
‚Ä¢ Custom native background service module

5.10 LOCAL STORAGE
------------------
Room + SharedPreferences ‚Üí AsyncStorage + SQLite

Current:
‚Ä¢ Room Database
‚Ä¢ SharedPreferences
‚Ä¢ File system

Target:
‚Ä¢ @react-native-async-storage/async-storage
‚Ä¢ expo-sqlite
‚Ä¢ expo-file-system
‚Ä¢ react-native-mmkv (high-performance alternative)

5.11 ANIMATIONS
---------------
Android Animations ‚Üí React Native Animated

Current:
‚Ä¢ Property Animation
‚Ä¢ Compose animations

Target:
‚Ä¢ React Native Animated API
‚Ä¢ react-native-reanimated (better performance)
‚Ä¢ Lottie (lottie-react-native)

5.12 TESTING
------------
JUnit + Espresso ‚Üí Jest + Detox

Current:
‚Ä¢ JUnit 4.13.2
‚Ä¢ Espresso 3.6.1
‚Ä¢ AndroidX Test

Target:
‚Ä¢ Jest (unit tests)
‚Ä¢ React Native Testing Library
‚Ä¢ Detox (E2E tests)
‚Ä¢ @testing-library/react-native

5.13 BUILD & DEPLOYMENT
-----------------------
Gradle ‚Üí Metro + EAS Build

Current:
‚Ä¢ Gradle
‚Ä¢ Android Studio
‚Ä¢ Play Store Console

Target:
‚Ä¢ Metro bundler
‚Ä¢ EAS Build (Expo Application Services)
‚Ä¢ EAS Submit
‚Ä¢ App Store Connect (iOS)
‚Ä¢ Play Store Console (Android)

================================================================================
6. COMPONENT MIGRATION MAP
================================================================================

6.1 AGENT CORE
--------------
| Kotlin File | React Native/TypeScript Equivalent |
|-------------|-----------------------------------|
| v2/Agent.kt | src/agent/Agent.ts |
| v2/AgentModel.kt | src/agent/types.ts |
| v2/AgentService.kt | src/services/AgentService.ts + native module |
| v2/PromptBuilder.kt | src/agent/PromptBuilder.ts |
| v2/message_manager/MemoryManager.kt | src/agent/MemoryManager.ts |
| v2/perception/Perception.kt | src/agent/Perception.ts |
| v2/perception/SemanticParser.kt | src/agent/SemanticParser.ts |
| v2/actions/Action.kt | src/agent/actions/types.ts |
| v2/actions/ActionExecutor.kt | src/agent/actions/ActionExecutor.ts |
| v2/fs/FileSystem.kt | src/services/FileSystem.ts |
| v2/llm/GeminiAPI.kt | src/api/GeminiClient.ts |
| v2/llm/models.kt | src/api/types.ts |
| v2/logging/TaskLogger.kt | src/utils/TaskLogger.ts |

6.2 API INTEGRATIONS
--------------------
| Kotlin File | React Native/TypeScript Equivalent |
|-------------|-----------------------------------|
| api/GeminiApi.kt | src/api/GeminiClient.ts |
| api/Eyes.kt | Native module + src/native/Eyes.ts |
| api/Finger.kt | Native module + src/native/Gestures.ts |
| api/GoogleTTS.kt | src/services/TTSService.ts |
| api/TavilyApi.kt | src/api/TavilyClient.ts |
| api/MemoryService.kt | src/api/MemoryClient.ts |
| api/PorcupineWakeWordDetector.kt | src/services/WakeWordService.ts |
| api/PicovoiceKeyManager.kt | src/services/PicovoiceKeyManager.ts |

6.3 ACTIVITIES ‚Üí SCREENS
------------------------
| Android Activity | React Native Screen |
|-----------------|---------------------|
| MainActivity.kt | src/screens/HomeScreen.tsx |
| LoginActivity.kt | src/screens/LoginScreen.tsx |
| ChatActivity.kt | src/screens/ChatScreen.tsx |
| DialogueActivity.kt | src/screens/DialogueScreen.tsx |
| SettingsActivity.kt | src/screens/SettingsScreen.tsx |
| PermissionsActivity.kt | src/screens/PermissionsScreen.tsx |
| OnboardingPermissionsActivity.kt | src/screens/OnboardingScreen.tsx |
| MemoriesActivity.kt | src/screens/MemoriesScreen.tsx |
| MomentsActivity.kt | src/screens/MomentsScreen.tsx |
| ProPurchaseActivity.kt | src/screens/SubscriptionScreen.tsx |
| triggers/ui/TriggersActivity.kt | src/screens/TriggersScreen.tsx |
| triggers/ui/CreateTriggerActivity.kt | src/screens/CreateTriggerScreen.tsx |

6.4 SERVICES
------------
| Android Service | React Native Equivalent |
|----------------|------------------------|
| ScreenInteractionService.kt | Native module (Android/iOS) |
| v2/AgentService.kt | Native background module + JS coordinator |
| services/EnhancedWakeWordService.kt | Background task + native module |
| services/FloatingOpenFlowButtonService.kt | Native overlay module |
| triggers/TriggerMonitoringService.kt | expo-task-manager + scheduler |
| triggers/OpenFlowNotificationListenerService.kt | Native notification module |

6.5 UTILITIES
-------------
| Kotlin File | React Native/TypeScript Equivalent |
|-------------|-----------------------------------|
| utilities/TTSManager.kt | src/services/TTSManager.ts |
| utilities/STTManager.kt | src/services/STTManager.ts |
| utilities/SpeechCoordinator.kt | src/services/SpeechCoordinator.ts |
| utilities/ApiKeyManager.kt | src/utils/ApiKeyManager.ts |
| utilities/FreemiumManager.kt | src/services/SubscriptionManager.ts |
| utilities/PermissionManager.kt | src/utils/PermissionManager.ts |
| utilities/OnboardingManager.kt | src/utils/OnboardingManager.ts |
| utilities/OpenFlowStateManager.kt | src/state/AppStateManager.ts |
| utilities/Logger.kt | src/utils/Logger.ts |
| utilities/NetworkConnectivityManager.kt | @react-native-community/netinfo |

6.6 DATA LAYER
--------------
| Kotlin/Room | React Native Equivalent |
|------------|------------------------|
| data/AppDatabase.kt | src/database/Database.ts (SQLite) |
| data/Memory.kt | src/models/Memory.ts |
| data/MemoryDao.kt | src/database/MemoryDao.ts |
| data/TaskHistoryItem.kt | src/models/TaskHistory.ts |
| SharedPreferences | AsyncStorage wrapper |

6.7 TRIGGERS
------------
| Kotlin File | React Native/TypeScript Equivalent |
|-------------|-----------------------------------|
| triggers/Trigger.kt | src/models/Trigger.ts |
| triggers/TriggerManager.kt | src/services/TriggerManager.ts |
| triggers/TriggerReceiver.kt | Native module + event handler |
| triggers/BootReceiver.kt | Native module |
| triggers/ChargingStateReceiver.kt | expo-battery + event handler |

6.8 OVERLAY SYSTEM
------------------
| Kotlin File | React Native Equivalent |
|-------------|------------------------|
| overlay/OverlayManager.kt | Native module + src/services/OverlayManager.ts |
| overlay/OverlayDispatcher.kt | src/services/OverlayDispatcher.ts |
| overlay/OverlayState.kt | src/state/overlaySlice.ts (Redux) |

6.9 AGENTS
----------
| Kotlin File | React Native/TypeScript Equivalent |
|-------------|-----------------------------------|
| agents/ClarificationAgent.kt | src/agents/ClarificationAgent.ts |

================================================================================
7. NATIVE MODULE REQUIREMENTS
================================================================================

‚ö†Ô∏è CRITICAL: These native modules are ESSENTIAL for app functionality

7.1 ACCESSIBILITY MODULE (Android)
----------------------------------
Module: @openflow/accessibility-service

Purpose: Bridge to Android Accessibility Service

Required APIs:
‚úì captureScreen(): Promise<string> - Screenshot as base64
‚úì getScreenHierarchy(): Promise<ScreenNode[]> - UI tree
‚úì tapElement(x: number, y: number): Promise<void>
‚úì longPressElement(x: number, y: number): Promise<void>
‚úì swipe(startX, startY, endX, endY, duration): Promise<void>
‚úì typeText(text: string): Promise<void>
‚úì pressBack(): Promise<void>
‚úì pressHome(): Promise<void>
‚úì openRecents(): Promise<void>
‚úì scrollUp(amount: number): Promise<void>
‚úì scrollDown(amount: number): Promise<void>
‚úì getForegroundApp(): Promise<string> - Package name
‚úì getScreenDimensions(): Promise<{width, height}>
‚úì isKeyboardVisible(): Promise<boolean>

Event Emitters:
‚Ä¢ onWindowStateChanged
‚Ä¢ onScreenChanged
‚Ä¢ onKeyboardVisibilityChanged

Implementation: Full Android Accessibility Service in Java/Kotlin

7.2 SCREEN AUTOMATION MODULE (iOS)
-----------------------------------
Module: @openflow/ios-automation

Purpose: Limited iOS screen automation (VERY LIMITED)

Note: iOS has strict sandbox. Cannot automate outside app.

Possible APIs:
‚úì captureInAppScreen(): Promise<string>
‚úì simulateDeepLinks(): Promise<void>
‚úó System-wide automation: NOT POSSIBLE

Alternative: Use XCTest framework for testing only

7.3 BACKGROUND SERVICE MODULE
------------------------------
Module: @openflow/background-service

Purpose: Long-running agent execution

Required APIs:
‚úì startForegroundService(title, body): Promise<void>
‚úì stopForegroundService(): Promise<void>
‚úì updateNotification(title, body): Promise<void>
‚úì isServiceRunning(): Promise<boolean>

Events:
‚Ä¢ onServiceStarted
‚Ä¢ onServiceStopped
‚Ä¢ onServiceError

Implementation: Android Service + iOS Background Tasks (limited)

7.4 NOTIFICATION LISTENER MODULE
---------------------------------
Module: @openflow/notification-listener

Purpose: Monitor system notifications for triggers

Required APIs:
‚úì requestPermission(): Promise<boolean>
‚úì hasPermission(): Promise<boolean>
‚úì startListening(): Promise<void>
‚úì stopListening(): Promise<void>

Events:
‚Ä¢ onNotificationPosted(app, title, body)
‚Ä¢ onNotificationRemoved(app)

Implementation: NotificationListenerService (Android only)

7.5 OVERLAY MODULE
------------------
Module: @openflow/overlay

Purpose: System-wide overlay windows

Required APIs:
‚úì requestOverlayPermission(): Promise<boolean>
‚úì hasOverlayPermission(): Promise<boolean>
‚úì showOverlay(text, duration, position): Promise<void>
‚úì hideOverlay(): Promise<void>

Implementation: WindowManager (Android), limited on iOS

7.6 GESTURE CONTROL MODULE
---------------------------
Module: @openflow/gesture-controller

Purpose: Advanced gesture dispatch

Required APIs:
‚úì dispatchGesture(path: GesturePath[]): Promise<void>
‚úì multiPointGesture(paths: GesturePath[][]): Promise<void>

Implementation: AccessibilityService GestureDescription (Android)

7.7 APP LAUNCHER MODULE
------------------------
Module: @openflow/app-launcher

Purpose: Launch other apps

Required APIs:
‚úì getInstalledApps(): Promise<AppInfo[]>
‚úì launchApp(packageName: string): Promise<boolean>
‚úì canLaunchApp(packageName): Promise<boolean>

Implementation: PackageManager + Intent (Android), URL schemes (iOS)

7.8 NATIVE MODULE DEVELOPMENT GUIDE
------------------------------------
For each module:

1. Create module in Expo bare workflow:
   ```bash
   npx create-expo-module @openflow/module-name
   ```

2. Implement Android side:
   - Create Java/Kotlin class extending ReactContextBaseJavaModule
   - Implement native methods with @ReactMethod annotation
   - Handle permissions and lifecycle

3. Implement iOS side (if possible):
   - Create Objective-C/Swift class conforming to RCTBridgeModule
   - Implement native methods with RCT_EXPORT_METHOD

4. Create TypeScript definitions:
   ```typescript
   export interface AccessibilityModule {
     captureScreen(): Promise<string>;
     // ... more methods
   }
   ```

5. Document and test thoroughly

================================================================================
8. API & SERVICE INTEGRATION
================================================================================

8.1 GEMINI AI
-------------
Migration: Direct port, minimal changes

Current: OkHttp + JSON parsing
Target: Axios + native JSON

Changes:
‚Ä¢ Replace OkHttp with Axios
‚Ä¢ Keep retry logic
‚Ä¢ Keep key rotation
‚Ä¢ Keep proxy/direct mode logic

Example:
```typescript
// src/api/GeminiClient.ts
import axios from 'axios';

class GeminiClient {
  async generateContent(messages: Message[]): Promise<AgentOutput> {
    const response = await axios.post(
      this.proxyUrl,
      { modelName: this.model, messages },
      { 
        headers: { 'X-API-Key': this.getNextKey() },
        timeout: 60000 
      }
    );
    return response.data;
  }
}
```

8.2 FIREBASE
------------
Migration: Use @react-native-firebase

Setup:
```bash
npm install @react-native-firebase/app
npm install @react-native-firebase/auth
npm install @react-native-firebase/firestore
npm install @react-native-firebase/analytics
npm install @react-native-firebase/crashlytics
npm install @react-native-firebase/remote-config
```

Configuration:
‚Ä¢ Add google-services.json (Android)
‚Ä¢ Add GoogleService-Info.plist (iOS)
‚Ä¢ Configure app.json for Expo

Example:
```typescript
// src/services/FirebaseService.ts
import auth from '@react-native-firebase/auth';
import firestore from '@react-native-firebase/firestore';

class FirebaseService {
  async signInWithEmail(email: string, password: string) {
    return await auth().signInWithEmailAndPassword(email, password);
  }
  
  async saveTask(task: Task) {
    await firestore().collection('tasks').add(task);
  }
}
```

8.3 PICOVOICE (Wake Word)
--------------------------
Migration: Use React Native package

Setup:
```bash
npm install @picovoice/react-native-porcupine
```

Example:
```typescript
// src/services/WakeWordService.ts
import { PorcupineManager } from '@picovoice/react-native-porcupine';

class WakeWordService {
  async start() {
    this.manager = await PorcupineManager.fromKeywordPaths(
      'YOUR_ACCESS_KEY',
      ['path/to/keyword.ppn'],
      (keywordIndex) => {
        console.log('Wake word detected!');
      }
    );
    await this.manager.start();
  }
}
```

8.4 GOOGLE CLOUD TTS
--------------------
Migration: Keep existing HTTP API calls

No change needed. Continue using HTTP requests.

8.5 TAVILY SEARCH
-----------------
Migration: Direct port

Example:
```typescript
// src/api/TavilyClient.ts
import axios from 'axios';

class TavilyClient {
  async search(query: string) {
    const response = await axios.post(
      'https://api.tavily.com/search',
      { query, api_key: this.apiKey }
    );
    return response.data;
  }
}
```

================================================================================
9. TESTING STRATEGY
================================================================================

9.1 UNIT TESTING
----------------
Framework: Jest

Setup:
```bash
npm install --save-dev jest @testing-library/react-native
```

Test Structure:
```
__tests__/
‚îú‚îÄ‚îÄ agent/
‚îÇ   ‚îú‚îÄ‚îÄ Agent.test.ts
‚îÇ   ‚îú‚îÄ‚îÄ PromptBuilder.test.ts
‚îÇ   ‚îî‚îÄ‚îÄ ActionExecutor.test.ts
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ TTSManager.test.ts
‚îÇ   ‚îî‚îÄ‚îÄ STTManager.test.ts
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ ApiKeyManager.test.ts
‚îî‚îÄ‚îÄ api/
    ‚îî‚îÄ‚îÄ GeminiClient.test.ts
```

Example:
```typescript
// __tests__/agent/Agent.test.ts
import { Agent } from '../../src/agent/Agent';

describe('Agent', () => {
  it('should execute task successfully', async () => {
    const agent = new Agent(mockConfig);
    const result = await agent.run('Open Chrome');
    expect(result.success).toBe(true);
  });
});
```

9.2 INTEGRATION TESTING
------------------------
Focus: API integrations, native modules

Example:
```typescript
// __tests__/integration/Accessibility.test.ts
import { AccessibilityModule } from '../../src/native/Accessibility';

describe('Accessibility Module', () => {
  it('should capture screen', async () => {
    const base64 = await AccessibilityModule.captureScreen();
    expect(base64).toBeDefined();
    expect(base64.length).toBeGreaterThan(0);
  });
});
```

9.3 E2E TESTING
---------------
Framework: Detox

Setup:
```bash
npm install --save-dev detox
detox init
```

Test Structure:
```
e2e/
‚îú‚îÄ‚îÄ login.e2e.ts
‚îú‚îÄ‚îÄ voiceCommand.e2e.ts
‚îú‚îÄ‚îÄ triggers.e2e.ts
‚îî‚îÄ‚îÄ settings.e2e.ts
```

Example:
```typescript
// e2e/voiceCommand.e2e.ts
describe('Voice Command', () => {
  it('should execute voice command', async () => {
    await element(by.id('mic-button')).tap();
    // Simulate voice input (requires custom native module)
    await waitFor(element(by.text('Task completed')))
      .toBeVisible()
      .withTimeout(10000);
  });
});
```

9.4 MANUAL TESTING CHECKLIST
-----------------------------
‚ñ° Voice input (TTS/STT)
‚ñ° Wake word detection
‚ñ° Task execution (simple)
‚ñ° Task execution (complex)
‚ñ° Triggers (all types)
‚ñ° Permission flows
‚ñ° Subscription flow
‚ñ° Settings changes
‚ñ° Offline behavior
‚ñ° Error handling
‚ñ° UI on different screen sizes
‚ñ° Dark mode
‚ñ° Accessibility features

================================================================================
10. RISK MITIGATION
================================================================================

10.1 TECHNICAL RISKS
--------------------
Risk 1: Native Module Complexity
Severity: HIGH
Impact: Critical features may not work
Mitigation:
‚Ä¢ Build proof of concept early (Phase 0)
‚Ä¢ Hire Android/iOS native developers
‚Ä¢ Budget extra time for native development
‚Ä¢ Consider abandoning migration if PoC fails

Risk 2: Performance Degradation
Severity: MEDIUM
Impact: Slower task execution, poor UX
Mitigation:
‚Ä¢ Use Hermes engine
‚Ä¢ Optimize bundle size
‚Ä¢ Profile early and often
‚Ä¢ Move critical operations to native modules

Risk 3: Background Task Limitations
Severity: HIGH
Impact: Agent may not run reliably in background
Mitigation:
‚Ä¢ Extensive testing on different Android versions
‚Ä¢ Use foreground service notifications
‚Ä¢ Educate users on battery optimization
‚Ä¢ Consider wake lock strategies

Risk 4: Team Expertise
Severity: MEDIUM
Impact: Slower development, more bugs
Mitigation:
‚Ä¢ Training on React Native
‚Ä¢ Hire React Native experts
‚Ä¢ Pair programming
‚Ä¢ Code reviews

Risk 5: Breaking Changes in Dependencies
Severity: MEDIUM
Impact: Build failures, feature breakage
Mitigation:
‚Ä¢ Lock dependency versions
‚Ä¢ Regular updates and testing
‚Ä¢ Monitor deprecation notices
‚Ä¢ Have rollback plans

10.2 PROJECT RISKS
------------------
Risk 6: Scope Creep
Severity: MEDIUM
Impact: Delayed launch, budget overrun
Mitigation:
‚Ä¢ Strict scope definition
‚Ä¢ Change control process
‚Ä¢ Regular stakeholder alignment
‚Ä¢ MVP-first approach

Risk 7: Timeline Slippage
Severity: HIGH
Impact: Missed deadlines, competitive disadvantage
Mitigation:
‚Ä¢ Buffer time in estimates (30%)
‚Ä¢ Weekly progress reviews
‚Ä¢ Early identification of blockers
‚Ä¢ Parallel workstreams

Risk 8: Resource Availability
Severity: MEDIUM
Impact: Development slowdown
Mitigation:
‚Ä¢ Cross-training team members
‚Ä¢ Documentation
‚Ä¢ Backup resources identified

10.3 BUSINESS RISKS
-------------------
Risk 9: User Adoption
Severity: MEDIUM
Impact: Users prefer old app
Mitigation:
‚Ä¢ Beta testing program
‚Ä¢ Gradual rollout
‚Ä¢ Keep Android app available initially
‚Ä¢ Gather feedback early

Risk 10: Feature Parity
Severity: HIGH
Impact: Missing features frustrate users
Mitigation:
‚Ä¢ Feature comparison matrix
‚Ä¢ Prioritize critical features
‚Ä¢ Communicate limitations clearly
‚Ä¢ Phased feature rollout

================================================================================
11. ALTERNATIVE APPROACHES
================================================================================

11.1 ALTERNATIVE 1: Stay with Native Android
---------------------------------------------
Recommendation: STRONGLY CONSIDER THIS

Pros:
‚úÖ No migration cost
‚úÖ Full Android API access
‚úÖ Better performance
‚úÖ Existing codebase is mature
‚úÖ Team expertise

Cons:
‚ùå No iOS support
‚ùå No web support
‚ùå Smaller developer pool

When to Choose:
‚Ä¢ If Android-only is acceptable
‚Ä¢ If core features require deep Android integration
‚Ä¢ If team is comfortable with Kotlin

11.2 ALTERNATIVE 2: Flutter
---------------------------
Recommendation: BETTER THAN REACT NATIVE for this app

Pros:
‚úÖ Better native API access than React Native
‚úÖ Platform channels easier than native modules
‚úÖ Better performance
‚úÖ Cross-platform (Android, iOS, Web)
‚úÖ Growing ecosystem

Cons:
‚ùå Different language (Dart)
‚ùå Smaller community than React Native
‚ùå Still requires native code for accessibility

When to Choose:
‚Ä¢ If cross-platform is required
‚Ä¢ If performance is critical
‚Ä¢ If team willing to learn Dart

11.3 ALTERNATIVE 3: Kotlin Multiplatform Mobile (KMM)
-----------------------------------------------------
Recommendation: IDEAL for this project

Pros:
‚úÖ Share business logic in Kotlin
‚úÖ Native UI (keep Compose Android, SwiftUI iOS)
‚úÖ Best performance
‚úÖ Gradual migration (share logic first)
‚úÖ Keep existing Kotlin code
‚úÖ Full native API access

Cons:
‚ùå Relatively new technology
‚ùå iOS team needs Swift knowledge
‚ùå Smaller community

When to Choose:
‚Ä¢ If want to keep Kotlin
‚Ä¢ If gradual migration preferred
‚Ä¢ If iOS support needed
‚Ä¢ If performance critical

11.4 ALTERNATIVE 4: Progressive Web App (PWA)
----------------------------------------------
Recommendation: NOT SUITABLE

Pros:
‚úÖ Web + mobile
‚úÖ No app store approval

Cons:
‚ùå Cannot access Android Accessibility Service
‚ùå Cannot run in background reliably
‚ùå Cannot control device
‚ùå Limited permissions

When to Choose:
‚Ä¢ Never for this use case

11.5 ALTERNATIVE 5: Hybrid Approach
------------------------------------
Recommendation: PRAGMATIC OPTION

Keep core Android app for automation
Build React Native companion app for:
‚Ä¢ UI/UX
‚Ä¢ Settings
‚Ä¢ Task management
‚Ä¢ Viewing results

Communication: IPC or shared database

Pros:
‚úÖ Best of both worlds
‚úÖ Faster migration
‚úÖ Leverage React Native for UI
‚úÖ Keep native for automation

Cons:
‚ùå Two codebases to maintain
‚ùå Synchronization complexity

When to Choose:
‚Ä¢ If want React Native benefits without full rewrite
‚Ä¢ If automation must remain native

11.6 DECISION MATRIX
--------------------
Option | Cross-Platform | Performance | Dev Speed | Maintenance
-------|----------------|-------------|-----------|------------
Stay Native | ‚ùå | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê
React Native | ‚úÖ | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê
Flutter | ‚úÖ | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê
KMM | ‚úÖ | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê
Hybrid | Partial | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê

================================================================================
12. DETAILED IMPLEMENTATION STEPS
================================================================================

12.1 STEP-BY-STEP: Project Initialization
------------------------------------------
Step 1: Create Expo Project (Bare Workflow)
```bash
npx create-expo-app openflow-rn --template expo-template-bare-minimum
cd openflow-rn
```

Step 2: Add TypeScript
```bash
npm install --save-dev typescript @types/react @types/react-native
npx tsc --init
```

Step 3: Configure TypeScript (tsconfig.json)
```json
{
  "compilerOptions": {
    "target": "esnext",
    "module": "commonjs",
    "lib": ["es2019"],
    "jsx": "react-native",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

Step 4: Project Structure
```bash
mkdir -p src/{screens,components,navigation,services,api,utils,models,state,native,agent,config}
```

Step 5: Install Core Dependencies
```bash
# Navigation
npm install @react-navigation/native @react-navigation/stack
npm install react-native-screens react-native-safe-area-context

# State Management
npm install @reduxjs/toolkit react-redux

# UI
npm install react-native-paper

# Firebase
npm install @react-native-firebase/app @react-native-firebase/auth
npm install @react-native-firebase/firestore @react-native-firebase/analytics

# Voice
npm install expo-speech react-native-voice
npm install @picovoice/react-native-porcupine

# Utilities
npm install axios
npm install @react-native-async-storage/async-storage
npm install expo-file-system expo-sqlite

# Development
npm install --save-dev @typescript-eslint/parser @typescript-eslint/eslint-plugin
npm install --save-dev prettier eslint-config-prettier eslint-plugin-prettier
```

Step 6: Configure ESLint (.eslintrc.js)
```javascript
module.exports = {
  root: true,
  extends: [
    '@react-native-community',
    'plugin:@typescript-eslint/recommended',
    'prettier',
  ],
  parser: '@typescript-eslint/parser',
  plugins: ['@typescript-eslint'],
};
```

Step 7: Configure Prettier (.prettierrc)
```json
{
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "es5"
}
```

Step 8: Configure app.json
```json
{
  "expo": {
    "name": "OpenFlow-AI",
    "slug": "openflow-rn",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "automatic",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "assetBundlePatterns": ["**/*"],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.openflow.app"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.seemoo.openflow",
      "permissions": [
        "RECORD_AUDIO",
        "INTERNET",
        "ACCESS_NETWORK_STATE",
        "FOREGROUND_SERVICE",
        "SYSTEM_ALERT_WINDOW",
        "RECEIVE_BOOT_COMPLETED"
      ]
    },
    "plugins": [
      "@react-native-firebase/app",
      "expo-build-properties"
    ]
  }
}
```

12.2 STEP-BY-STEP: Native Module Creation (Android)
----------------------------------------------------
Example: Accessibility Module

Step 1: Create Native Module Package
```bash
cd android
mkdir -p app/src/main/java/com/openflow/accessibility
```

Step 2: Create Module File (AccessibilityModule.java)
```java
package com.openflow.accessibility;

import com.facebook.react.bridge.*;
import com.facebook.react.modules.core.DeviceEventManagerModule;

public class AccessibilityModule extends ReactContextBaseJavaModule {
    private static final String MODULE_NAME = "AccessibilityModule";
    
    public AccessibilityModule(ReactApplicationContext context) {
        super(context);
    }
    
    @Override
    public String getName() {
        return MODULE_NAME;
    }
    
    @ReactMethod
    public void captureScreen(Promise promise) {
        // Implementation here
        try {
            String base64 = captureScreenInternal();
            promise.resolve(base64);
        } catch (Exception e) {
            promise.reject("CAPTURE_ERROR", e.getMessage());
        }
    }
    
    @ReactMethod
    public void tapElement(double x, double y, Promise promise) {
        // Implementation here
    }
    
    // More methods...
}
```

Step 3: Create Package File (AccessibilityPackage.java)
```java
package com.openflow.accessibility;

import com.facebook.react.ReactPackage;
import com.facebook.react.bridge.NativeModule;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.uimanager.ViewManager;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class AccessibilityPackage implements ReactPackage {
    @Override
    public List<NativeModule> createNativeModules(ReactApplicationContext context) {
        List<NativeModule> modules = new ArrayList<>();
        modules.add(new AccessibilityModule(context));
        return modules;
    }

    @Override
    public List<ViewManager> createViewManagers(ReactApplicationContext context) {
        return Collections.emptyList();
    }
}
```

Step 4: Register Package (MainApplication.java)
```java
import com.openflow.accessibility.AccessibilityPackage;

@Override
protected List<ReactPackage> getPackages() {
    List<ReactPackage> packages = new PackageList(this).getPackages();
    packages.add(new AccessibilityPackage());
    return packages;
}
```

Step 5: Create TypeScript Interface
```typescript
// src/native/AccessibilityModule.ts
import { NativeModules } from 'react-native';

interface IAccessibilityModule {
  captureScreen(): Promise<string>;
  tapElement(x: number, y: number): Promise<void>;
  // More methods...
}

const { AccessibilityModule } = NativeModules;

export default AccessibilityModule as IAccessibilityModule;
```

Step 6: Use in Code
```typescript
// src/services/ScreenCaptureService.ts
import AccessibilityModule from '../native/AccessibilityModule';

class ScreenCaptureService {
  async capture(): Promise<string> {
    try {
      const base64 = await AccessibilityModule.captureScreen();
      return base64;
    } catch (error) {
      console.error('Screen capture failed:', error);
      throw error;
    }
  }
}
```

12.3 STEP-BY-STEP: Agent Core Migration
----------------------------------------
Example: Porting Agent.kt to Agent.ts

Step 1: Define Types
```typescript
// src/agent/types.ts
export interface AgentSettings {
  maxSteps: number;
  maxActions: number;
  maxFailures: number;
}

export interface AgentState {
  stopped: boolean;
  nSteps: number;
  consecutiveFailures: number;
  lastModelOutput?: AgentOutput;
  lastResult?: ActionResult[];
}

export interface ScreenState {
  currentApp: string;
  elements: UIElement[];
  screenshot?: string;
  dimensions: { width: number; height: number };
}
```

Step 2: Create Agent Class
```typescript
// src/agent/Agent.ts
import { AgentSettings, AgentState, ScreenState } from './types';
import { Perception } from './Perception';
import { GeminiClient } from '../api/GeminiClient';
import { ActionExecutor } from './actions/ActionExecutor';
import { MemoryManager } from './MemoryManager';
import { FileSystem } from '../services/FileSystem';
import { SpeechCoordinator } from '../services/SpeechCoordinator';

export class Agent {
  private state: AgentState;
  private history: AgentHistory[];
  
  constructor(
    private settings: AgentSettings,
    private memoryManager: MemoryManager,
    private perception: Perception,
    private llmClient: GeminiClient,
    private actionExecutor: ActionExecutor,
    private fileSystem: FileSystem,
    private speechCoordinator: SpeechCoordinator
  ) {
    this.state = {
      stopped: false,
      nSteps: 0,
      consecutiveFailures: 0,
    };
    this.history = [];
  }
  
  async run(initialTask: string, maxSteps: number = 150): Promise<void> {
    this.memoryManager.addNewTask(initialTask);
    this.state.stopped = false;
    
    console.log(`--- Agent starting task: '${initialTask}' ---`);
    
    while (!this.state.stopped && this.state.nSteps <= maxSteps) {
      console.log(`\n--- Step ${this.state.nSteps}/${maxSteps} ---`);
      
      // 1. SENSE
      console.log('üëÄ Sensing screen state...');
      const screenState = await this.perception.analyze();
      
      // 2. THINK (Prepare Prompt)
      console.log('üß† Preparing prompt...');
      this.memoryManager.createStateMessage(
        this.state.lastModelOutput,
        this.state.lastResult,
        { step: this.state.nSteps, maxSteps },
        screenState
      );
      
      // 3. THINK (Get Decision)
      console.log('ü§î Asking LLM for next action...');
      const messages = this.memoryManager.getMessages();
      const agentOutput = await this.llmClient.generateAgentOutput(messages);
      
      // Handle LLM Failure
      if (!agentOutput) {
        console.log('‚ùå LLM failed to return valid action. Retrying...');
        this.state.consecutiveFailures++;
        
        if (this.state.consecutiveFailures >= this.settings.maxFailures) {
          console.log('‚ùå Agent failed too many times. Stopping.');
          await this.speechCoordinator.speak(
            'Agent failed after multiple attempts. Stopping execution.'
          );
          break;
        }
        
        await new Promise(resolve => setTimeout(resolve, 1000));
        continue;
      }
      
      this.state.consecutiveFailures = 0;
      this.state.lastModelOutput = agentOutput;
      console.log(`ü§ñ LLM decided: ${agentOutput.nextGoal}`);
      
      // 4. ACT
      console.log('üí™ Executing actions...');
      const actionResults = [];
      
      for (const action of agentOutput.action) {
        const result = await this.actionExecutor.execute(
          action,
          screenState,
          this.fileSystem
        );
        actionResults.push(result);
        console.log(
          `  - Action '${action.type}' executed. Result: ${
            result.error || 'OK'
          }`
        );
        
        if (result.error) {
          console.log('  - üõë Action failed. Stopping current step.');
          break;
        }
      }
      
      this.state.lastResult = actionResults;
      
      // 5. RECORD
      this.history.push({
        modelOutput: agentOutput,
        result: actionResults,
        state: screenState,
        metadata: { timestamp: Date.now() },
      });
      
      // 6. CHECK STOP CONDITION
      const hasDoneAction = agentOutput.action.some(
        a => a.type === 'done'
      );
      if (hasDoneAction) {
        console.log('‚úÖ Agent completed task (done action).');
        this.state.stopped = true;
      }
      
      this.state.nSteps++;
    }
    
    if (this.state.nSteps > maxSteps) {
      console.log('‚è±Ô∏è Agent reached max steps.');
    }
    
    console.log('--- Agent finished ---');
  }
  
  getHistory() {
    return this.history;
  }
}
```

Step 3: Create Supporting Classes (similar pattern)
- Perception.ts
- ActionExecutor.ts
- MemoryManager.ts
- etc.

12.4 STEP-BY-STEP: Screen Migration
------------------------------------
Example: MainActivity ‚Üí HomeScreen

Step 1: Create Screen Component
```typescript
// src/screens/HomeScreen.tsx
import React, { useState, useEffect } from 'react';
import { View, StyleSheet, TouchableOpacity } from 'react-native';
import { Text, Button } from 'react-native-paper';
import { useSelector, useDispatch } from 'react-redux';
import { STTService } from '../services/STTService';
import { AgentService } from '../services/AgentService';

export const HomeScreen: React.FC = ({ navigation }) => {
  const [isListening, setIsListening] = useState(false);
  const [taskInput, setTaskInput] = useState('');
  const user = useSelector(state => state.auth.user);
  const isAgentRunning = useSelector(state => state.agent.isRunning);
  
  const handleMicPress = async () => {
    setIsListening(true);
    const text = await STTService.listen();
    setIsListening(false);
    
    if (text) {
      setTaskInput(text);
      await handleExecuteTask(text);
    }
  };
  
  const handleExecuteTask = async (task: string) => {
    try {
      await AgentService.startTask(task);
    } catch (error) {
      console.error('Task execution failed:', error);
    }
  };
  
  return (
    <View style={styles.container}>
      <Text variant="headlineLarge">OpenFlow-AI</Text>
      
      <TouchableOpacity
        style={[styles.micButton, isListening && styles.micButtonActive]}
        onPress={handleMicPress}
        disabled={isAgentRunning}
      >
        <Text style={styles.micIcon}>üé§</Text>
      </TouchableOpacity>
      
      <Text variant="bodyMedium">
        {isListening ? 'Listening...' : 'Hold to speak'}
      </Text>
      
      <Button
        mode="contained"
        onPress={() => navigation.navigate('Settings')}
        style={styles.button}
      >
        Settings
      </Button>
      
      <Button
        mode="outlined"
        onPress={() => navigation.navigate('Triggers')}
        style={styles.button}
      >
        Triggers
      </Button>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  micButton: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: '#007AFF',
    alignItems: 'center',
    justifyContent: 'center',
    marginVertical: 20,
  },
  micButtonActive: {
    backgroundColor: '#FF3B30',
  },
  micIcon: {
    fontSize: 40,
  },
  button: {
    marginTop: 10,
    width: '80%',
  },
});
```

Step 2: Register in Navigation
```typescript
// src/navigation/AppNavigator.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { HomeScreen } from '../screens/HomeScreen';
import { SettingsScreen } from '../screens/SettingsScreen';
import { TriggersScreen } from '../screens/TriggersScreen';

const Stack = createStackNavigator();

export const AppNavigator = () => {
  return (
    <NavigationContainer>
      <Stack.Navigator initialRouteName="Home">
        <Stack.Screen 
          name="Home" 
          component={HomeScreen}
          options={{ title: 'OpenFlow-AI' }}
        />
        <Stack.Screen 
          name="Settings" 
          component={SettingsScreen} 
        />
        <Stack.Screen 
          name="Triggers" 
          component={TriggersScreen} 
        />
      </Stack.Navigator>
    </NavigationContainer>
  );
};
```

Step 3: Wire Up in App.tsx
```typescript
// App.tsx
import React from 'react';
import { Provider } from 'react-redux';
import { PaperProvider } from 'react-native-paper';
import { AppNavigator } from './src/navigation/AppNavigator';
import { store } from './src/state/store';

export default function App() {
  return (
    <Provider store={store}>
      <PaperProvider>
        <AppNavigator />
      </PaperProvider>
    </Provider>
  );
}
```

================================================================================
13. RESOURCE REQUIREMENTS
================================================================================

13.1 TEAM COMPOSITION
---------------------
Minimum Viable Team (6-12 months):

1. Technical Lead (1)
   - React Native expert
   - 5+ years experience
   - Full-time

2. Senior React Native Developers (2)
   - TypeScript expertise
   - State management
   - Full-time

3. Native Module Developers (2)
   - Android (Java/Kotlin) - Full-time
   - iOS (Swift) - Part-time

4. Backend Developer (1)
   - Firebase expertise
   - API integrations
   - Part-time

5. UI/UX Designer (1)
   - Mobile design
   - Part-time

6. QA Engineer (1)
   - Mobile testing
   - Automation
   - Full-time

7. DevOps Engineer (1)
   - CI/CD
   - App store deployment
   - Part-time

Total: 5 FTE (full-time equivalent)

13.2 INFRASTRUCTURE
-------------------
Development:
‚Ä¢ MacBook Pro (for iOS development) - $2,500 ea x 5 = $12,500
‚Ä¢ Android devices (testing) - $500 ea x 5 = $2,500
‚Ä¢ iOS devices (testing) - $800 ea x 3 = $2,400

Services:
‚Ä¢ Firebase (Blaze plan) - $500/month
‚Ä¢ EAS Build credits - $300/month
‚Ä¢ TestFlight - Free
‚Ä¢ Play Console - $25 one-time
‚Ä¢ Apple Developer - $99/year
‚Ä¢ CI/CD (GitHub Actions) - Free tier
‚Ä¢ Error tracking (Sentry) - $26/month

Total Infrastructure: $20,400 upfront + $826/month

13.3 THIRD-PARTY COSTS
----------------------
‚Ä¢ Gemini API - Pay as you go
‚Ä¢ Picovoice - Free tier or $0.01/query
‚Ä¢ Google Cloud TTS - $4/million characters
‚Ä¢ Firebase - Blaze plan usage-based
‚Ä¢ RevenueCat (if used) - Free tier

Estimated: $200-500/month depending on usage

13.4 TOTAL BUDGET ESTIMATE
---------------------------
Personnel (assuming $100k avg salary):
‚Ä¢ 5 FTE x $100k/year √∑ 12 months = $41,667/month
‚Ä¢ 12 months = $500,000

Infrastructure:
‚Ä¢ Upfront: $20,400
‚Ä¢ 12 months x $826 = $9,912

Services:
‚Ä¢ 12 months x $300 = $3,600

Contingency (20%): $106,782

TOTAL: $640,694 (~$640k for 12-month project)

For 6-month aggressive timeline: ~$320k

================================================================================
14. SUCCESS CRITERIA
================================================================================

14.1 TECHNICAL SUCCESS CRITERIA
--------------------------------
‚ñ° All core features functional:
  - Voice input/output
  - Task execution
  - Triggers
  - UI automation (Android)

‚ñ° Performance benchmarks met:
  - App launch < 3 seconds
  - Voice recognition < 500ms latency
  - Task execution no more than 20% slower than native

‚ñ° Test coverage:
  - Unit tests > 70%
  - Integration tests for all critical paths
  - E2E tests for main user journeys

‚ñ° Code quality:
  - No major bugs in production
  - ESLint/Prettier compliance
  - TypeScript strict mode

‚ñ° Cross-platform (if iOS included):
  - Feature parity where possible
  - Platform-specific features documented

14.2 BUSINESS SUCCESS CRITERIA
-------------------------------
‚ñ° User adoption:
  - 70% of existing users migrate within 3 months
  - User satisfaction score > 4.0/5.0

‚ñ° Performance:
  - Crash rate < 1%
  - ANR rate < 0.5%
  - User retention same or better than native app

‚ñ° App Store:
  - Play Store rating > 4.0
  - App Store rating > 4.0 (if iOS)
  - Approved on first submission

14.3 PROJECT SUCCESS CRITERIA
------------------------------
‚ñ° On time:
  - Launch within 10% of estimated timeline

‚ñ° On budget:
  - Total cost within 15% of estimate

‚ñ° Team satisfaction:
  - Low turnover during project
  - Knowledge transfer completed

================================================================================
FINAL RECOMMENDATIONS
================================================================================

VERDICT: MIGRATION IS POSSIBLE BUT NOT RECOMMENDED ‚ö†Ô∏è

Reasons:
1. Core feature (Accessibility Service) requires extensive native code
2. 6-12 month timeline with significant risk
3. ~$320k-640k cost
4. Feature compromises, especially on iOS
5. Performance may degrade

BETTER ALTERNATIVES (in order of preference):

1. ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê STAY WITH NATIVE ANDROID
   - Keep existing mature codebase
   - Add features instead of rewriting
   - Best for this use case

2. ‚≠ê‚≠ê‚≠ê‚≠ê KOTLIN MULTIPLATFORM MOBILE (KMM)
   - Share business logic
   - Keep native UI
   - Gradual migration
   - Leverage existing Kotlin

3. ‚≠ê‚≠ê‚≠ê FLUTTER
   - Better native access than RN
   - Good performance
   - Cross-platform

4. ‚≠ê‚≠ê REACT NATIVE (this plan)
   - Only if:
     * iOS is critical requirement
     * Team strongly prefers React ecosystem
     * Accept extensive native module work
     * Have budget and timeline

IF PROCEEDING WITH REACT NATIVE:
‚úì Use Expo Bare Workflow (not managed)
‚úì Build proof of concept first (Phase 0)
‚úì Budget for extensive native module development
‚úì Hire experienced React Native + native developers
‚úì Accept 12-18 month timeline
‚úì Plan for feature compromises
‚úì Consider hybrid approach (native automation, RN UI)

DECISION GATE:
After Phase 0 Proof of Concept (6 weeks), evaluate:
‚ñ° Can native modules provide core functionality?
‚ñ° Is performance acceptable?
‚ñ° Can timeline and budget be met?
‚ñ° Is team confident in approach?

If any answer is NO ‚Üí Abort migration, choose alternative

================================================================================
END OF MIGRATION PLAN
================================================================================

This migration plan is comprehensive but honest about challenges. The decision
to proceed should be based on business requirements, not just technical
possibility. Consider alternatives seriously.

Questions? Need clarification? Consult with experienced React Native architects
before committing to this path.

Good luck! üöÄ
